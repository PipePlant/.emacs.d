use strict;
use warnings;
use Data::Dumper;
use Encode;
use JSON;
use feature qw (say);

$| = 1;
my $tool_file = "./lib/functions.pl";
require $tool_file;

my $json = new JSON;

foreach my $dtype (GetDtypeArray()) {
	# next if $dtype ne "mickey";

	say "===> ".$dtype." <===";
	my $import_file = "obj_".$dtype."/tmp_data/".$dtype."_import_data.txt";
	my $audio_file = "./audio_img/".$dtype."/".$dtype."_audio.txt";
	my $img_file = "./audio_img/".$dtype."/".$dtype."_img.txt";
	
	my %senData = ();
	my %timeLine = ();

	# ```Tidy Sen```
	my $tidySenArrRef = GetSentence($dtype);
	# say Dumper$tidySenArrRef;exit;
	
	# ```IMG```
	open my $IMG ,"<", $img_file or die $!;
	while (my $line = <$IMG>) {
		chomp $line;
		if ($line =~ /\d+$/) {
			next;
		} else {
			$line =~ /(.*) @(.*)/;
			$senData{$1} = $2;
		}
	}
	close $IMG;

	# ```AUDIO```
	my $chapter = "";
	my %timeItem = ();
	open my $AUDIO ,"<", $audio_file or die $!;
	while (my $line = <$AUDIO>) {
		chomp $line;
		if ($line =~ /(\d+)$/) {
			$chapter = $1;
		} else {
			# $line =~ s/ +(\[\d+)/$1/g;
			$line =~ /(.*?) \[(\d+):(\d+)-(\d+):(\d+)\]/;
			my $sen = $1;
			if (!exists $senData{$sen}) {
				say "~~~ [audio line] ".$.." ~~~";
				say "===> ".$line;
				exit;
			}

			my $starTime = $2*60 + $3;
			my $endTime = $4*60 + $5;
			my $prevTime = 0;
			my $prevSen = "";
			my $prevImg = "";

			for (my $time = $starTime; $time <= $endTime; $time++) {
				if (exists $timeLine{$chapter}{$time}) {
					undef $timeLine{$chapter}{$time};
				}
				if ($prevSen eq $sen and
					$prevImg eq $senData{$sen}) {
					$timeLine{$chapter}{$time}{"link"} = $prevTime;
				} else {
					my $markSen = shift @{$tidySenArrRef};
					my $tmpMarkSen = $markSen;
					$tmpMarkSen =~ s/<.+?>//g;
					if ($tmpMarkSen ne $sen) {
						say "mark   ===> ".$markSen;
						say "unmark ===> ".$tmpMarkSen;
						say "sen    ===> ".$sen;
						say "~~~ [audio line] ".$.." ~~~";
						exit;
					}
					$timeLine{$chapter}{$time}{"sen"} = $markSen;
					$timeLine{$chapter}{$time}{"img"} = $senData{$sen};
					$prevTime = $time;
					push @{$timeItem{$chapter}},$time;
					$prevSen = $sen;
					$prevImg = $senData{$sen};
				}
			}
		}
	}

	my $chapterCount = keys %timeItem;
	for (my $cNum = 1; $cNum <= $chapterCount; $cNum++) {
		for (my $tNum = 0; $tNum < @{$timeItem{$cNum}}; $tNum++) {
			my $prevTime = $timeItem{$cNum}[$tNum-1] if $tNum;
			my $nextTime = $timeItem{$cNum}[$tNum+1] if $tNum < @{$timeItem{$cNum}}-1;
			my $time = $timeItem{$cNum}[$tNum];

			$timeLine{$cNum}{$time}{"prev"} = $prevTime if defined $prevTime;
			$timeLine{$cNum}{$time}{"next"} = $nextTime if defined $nextTime;
		}
	}

	close $AUDIO;
	my @importData = ();
	open my $IMPORT_IN ,"<", $import_file or die $!;
	my $chapterNum = 0;
	while (my $line = <$IMPORT_IN>) {
		chomp $line;
		my $obj = $json->decode($line);
		${$obj}{"sentence"}{"timeline"} = $timeLine{++$chapterNum};
		${$obj}{"sentence"}{"audio"} = "chapter_".$chapterNum.".mp3";
		push @importData,$obj;
	}
	close $IMPORT_IN;

	open my $IMPORT_OUT ,">", $import_file or die $!;
	foreach my $obj (@importData) {
		say $IMPORT_OUT $json->encode($obj);
	}
	close $IMPORT_OUT;
}

sub GetSentence {
	my ($dtype) = @_;
	my @senArray = ();
	my $sen_file = "obj_".$dtype."/tmp_data/".$dtype."_sen_mark_data.txt";

	open my $SEN ,"<", $sen_file or die $!;
	while (my $line = <$SEN>) {
		chomp $line;
		next if $line =~ /^\d+$/;
		push @senArray,$line;	
	}
	close $SEN;

	return \@senArray;
};