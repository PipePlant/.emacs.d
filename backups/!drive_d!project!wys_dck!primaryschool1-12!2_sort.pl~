use strict;
use warnings;
use Data::Dumper;
use Encode;
use JSON;
use feature qw(say);

my $jsonCoder = new JSON;

for my $num (1 .. 12) {

	my $sort_file = "./originaldata/1l\Q$num\E/list.json";
	my $tidy_file = "./tmpdocument/1l\Q$num\E_tidy_data.txt";

	my %tidyList;
	open IN_TIDY ,"< $tidy_file", or die $!;
	while (<IN_TIDY>) {

		chomp;
		my $line = $_;
		my $tidy = $jsonCoder->decode($line);
		my %tidy = %{$tidy};
		if (exists $tidy{"word"}) {
			push @{$tidyList{$tidy{"word"}}},$line;
		}else {
			say $line;
		}
	}

	close IN_TIDY;

	open IN_SORT ,"< $sort_file", or die $!;
	open OUT ,"> $tidy_file", or die $!;
	while (<IN_SORT>) {

		my $line = $_;
        if ($line =~ /"(.+?)\|(\d+)\|\d+\|\d+"/) {
        	my $word = $1;
        	my $index = $2+1;
	        my $data = shift @{$tidyList{$word}};

	        if ($data =~ /"index":(\d+)/) {

	        	my $wordIndex = $1;
	        	if ($wordIndex == $index) {

	        		say OUT $data;
	        	}
	        	else {

	        		push @{$tidyList{$word}},$data;
	        		redo;
	        	}
	        }
	        else {

				if ($data ne "" and
					defined $data)
				{
					my $item = $jsonCoder->decode($data);
					my %item = %{$item};
					
					$item{"index"} = int $index;

					say OUT $jsonCoder->encode(\%item);
				}
	        }
        }
	}
	close IN_SORT; 
	close OUT;
}
