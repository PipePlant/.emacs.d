use strict;
#use warnings;

# my $tmpdocument="./primaryschool1-12/";
# my $txtfile = "./primaryschool1-12/wys_dckxxfo_exam.txt";
# my $tmpdocument="./primaryschool1-8/";
# my $txtfile = "./primaryschool1-8/wys_dckxxft_exam.txt";
my $tmpdocument="./juniorschool/";
my $txtfile = "./juniorschool/wys_dckcz_.dict_sort.txt";
# my $tmpdocument="./highschool/";
# my $txtfile = "./highschool/wys_dckgz_.dict_sort.txt";
# my $tmpdocument="./primaryschool1-12/";
# my $txtfile = "./primaryschool1-12/wys_dckxxfo_exam.txt";
# my $tmpdocument="./primaryschool1-8/";
# my $txtfile = "./primaryschool1-8/wys_dckxxft_exam.txt";

my ($fileHead) = ($txtfile =~ m/^(.*)\./);
print $fileHead."\n";
my $cryptfile = $fileHead.".dgz";
my $tmpfile = $fileHead."_tmp.txt";

use Data::Dumper;
use IO::Compress::Gzip qw(gzip $GzipError);
use IO::Uncompress::Gunzip qw(gunzip);


#---------- seeds ---------#
our $a = 23691;
our $b = 16430;
our $c = 24729;
my $SequenceLength = 9041;
#--------------------------#


my $version = 208;
my $buff_length = 200*1024; #200K
my $block_head = 'DICT';
my $realLength = 0;
my @bytes = (0,0,0,0,0,0);
my $hasUWID = 1;
$bytes[0] = $hasUWID;


my $buff;

my $outStr = "";
my %uwid;

my $nIndex = 0;
print "reading data from $txtfile \n...\n";
open IN,"< $txtfile" or die $!;
open OUT,"> $tmpfile" or die $!;
while(<IN>){
    chomp;
    if(/^[^\t]+\t(\d+)/){
        if(exists($uwid{$1})){
            print $1."\n";
        }
        $uwid{$1} = $nIndex;
        $nIndex++;
    }
    else{
        print $_."\n";
    }
    print OUT $_,"\n";
}
close IN;

my @uwids = sort keys %uwid;
foreach my $id (@uwids){
    print OUT $uwid{$id},"\n";
}
close OUT;

my @sort = keys %uwid;
$nIndex = scalar(@sort);

my $realbuff = "";
open IN,"< $tmpfile" or die $!;
while(<IN>){
    if(length($_) + $realLength <= $buff_length){
        $realbuff .= $_;
        $realLength = length($realbuff);
        next;
    }

    my $tmpStr = $_;

    my $gzipOutput;
    gzip \$realbuff => \$gzipOutput;
    my $gzipLength = length($gzipOutput);

    # block head: 'DICT' 4 bytes
    $outStr .= $block_head;

    # gzip length 4 bytes
    $outStr .= chr( ($gzipLength>>24) & 255 ).chr( ($gzipLength>>16) & 255 ).chr( ($gzipLength>>8) & 255 ).chr( $gzipLength & 255 );

    # append data
    $outStr .= $gzipOutput;

    $realbuff = $tmpStr;
    $realLength = 0;

}
if(length($realbuff) > 0){
    my $gzipOutput;
    gzip \$realbuff => \$gzipOutput;
    my $gzipLength = length($gzipOutput);

    # block head: 'DICT' 4 bytes
    $outStr .= $block_head;

    # gzip length 4 bytes
    $outStr .= chr( ($gzipLength>>24) & 255 ).chr( ($gzipLength>>16) & 255 ).chr( ($gzipLength>>8) & 255 ).chr( $gzipLength & 255 );

    # append data
    $outStr .= $gzipOutput;
}
close IN;

unlink $tmpfile;

srand(time ^ $$);
srand(int(rand(100000000)) + time);
my $Aseed = int(rand(2000000000)) ;
print "Aseed = $Aseed, nIndex = $nIndex, version = $version\n";

my $sA = $Aseed;
my $randomSequence = "";

for(my $i = 0; $i < $SequenceLength ; $i++){
    $sA  = ($a * ($sA & 65535) + $b) % ($c+$i);
    $randomSequence .= chr($sA & 255);
}

my $crypticalStr = "";
my $uncrypticalStrLen = length($outStr);
my @randomSequence = split(//,$randomSequence);
my @crc = (0,0,0,0,0,0,0,0);
my $char = 0;
my $tmp = 0;
my $i = 0;
open IN,"<",\$outStr;
while(1){
    my $buff;
    read(IN,$buff,$SequenceLength);
    my $tmpCryptialStr;
    if(length($buff) < $SequenceLength){
        my $tmpRand = substr($randomSequence,0,length($buff));
        $tmpCryptialStr = ($buff ^ $tmpRand);

    }else{
        $tmpCryptialStr = ($buff ^ $randomSequence);
    }
    $crypticalStr .= $tmpCryptialStr;

    my @arr = split(//,$tmpCryptialStr);
    foreach my $t (@arr){
        $crc[$i++%8] ^= ord($t);
    }
    last if(length($buff) < $SequenceLength);
}

$nIndex ^= (($crc[2] & 255) << 24) + (($crc[1]&255) << 16) + (($crc[7]&255) << 8) + ($crc[4]&255);



my $head = "";
$head .= chr($version & 255);
$head .= chr(($nIndex >> 24) & 255 ).chr(($nIndex >> 16) & 255 ).chr(($nIndex >> 8) & 255 ).chr(($nIndex) & 255);
$head .= chr(($Aseed >> 24) & 255 ).chr(($Aseed >> 16) & 255 ).chr(($Aseed >> 8) & 255 ).chr(($Aseed) & 255);

#保存预留字节
$i = 6;
foreach my $b (@bytes){
    $b ^= $crc[$i++%8];
    $head .= chr($b & 255);
}

foreach my $c (@crc){
    $head .= chr($c & 255);
}

my $allOut = $head.$crypticalStr;
print "writing data to $cryptfile \n...\n";
open OUT,"> $cryptfile" or die $!;
binmode(OUT);
print OUT $allOut;
close OUT;

print "\nFinished!\n";
#my $wait_for_end = <STDIN>;
