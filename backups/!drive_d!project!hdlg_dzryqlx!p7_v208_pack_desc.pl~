use strict;
#use warnings;

# my $dtype = "hzbn_fldcqsjxtf";
# my $dir = "C:\\Users\\dict\\Desktop\\$dtype";
# my $pre = "$dir\\original_data";
# my $tmpdir = "$dir\\tmpdocument";
# my $out = "$dir\\output";
# require("$dir/tools/functions_kai.pl");
#
# my $txtfile = "$tmpdir/$dtype.studydescription.txt";
#
# #bin file format;
# # klen(2 bytes) + dlen(4 bytes) + key + value
#
# #my ($fileHead) = ($txtfile =~ m/^(.*)\./);
# my $fileHead = "$dtype.studydescription";
# my $cryptfile = "$dir/".$fileHead.'.dgz';
# my $tmpfile = "$dir/".$fileHead."_tmp.txt";

# my $tmpdocument="./final_data/";
my $txtfile = "./final_data/hdlg_dzyyqlx.studydescription.txt";

my ($fileHead) = ($txtfile =~ m/^(.*)\./);
print $fileHead."\n";
my $cryptfile = $fileHead.".dgz";
my $tmpfile = $fileHead."_tmp.txt";

use Data::Dumper;
use IO::Compress::Gzip qw(gzip $GzipError);
use IO::Uncompress::Gunzip qw(gunzip);
# sortfile($txtfile);

#---------- seeds ---------#
our $a = 23691;
our $b = 16430;
our $c = 24729;
my $SequenceLength = 9041;
#--------------------------#


my $version = 208;
my $buff_length = 200*1024; #200K
my $block_head = 'DICT';
my $realLength = 0;
my @bytes = (0,0,0,0,0,0);
my $hasUWID = 0;
$bytes[0] = $hasUWID;

my $buff;

my $outStr = "";
my %uwid;

my $nIndex = 0;
print "reading data from $txtfile \n...\n";

my $realbuff = "";
#my $buff;
my $len;
open IN,"< $txtfile" or die $!;
while(<IN>){
    chomp;
    my ($key,$val) = split(/\t/);
    my $valLength = length($val);
    my $valLenStr = chr( ($valLength>>24) & 255 ).chr( ($valLength>>16) & 255 ).chr( ($valLength>>8) & 255 ).chr( $valLength & 255 );
    $nIndex++;
    my $realLine = $key."\t".$valLenStr.$val."\n";
    if(length($realLine) + $realLength <= $buff_length){
        $realbuff .= $realLine;
        $realLength = length($realbuff);
        next;
    }

    #print $realbuff."\n";
    my $gzipOutput;
    gzip \$realbuff => \$gzipOutput;
    my $gzipLength = length($gzipOutput);

    # block head: 'DICT' 4 bytes
    $outStr .= $block_head;
    print $gzipLength,"\n";
    # gzip length 4 bytes
    $outStr .= chr( ($gzipLength>>24) & 255 ).chr( ($gzipLength>>16) & 255 ).chr( ($gzipLength>>8) & 255 ).chr( $gzipLength & 255 );

    # append data
    $outStr .= $gzipOutput;

    $realbuff = $realLine;
    $realLength = 0;

}
#print length($realbuff)," buff length\n";
if(length($realbuff) > 0){
    my $gzipOutput;
    gzip \$realbuff => \$gzipOutput;
    my $gzipLength = length($gzipOutput);

    # block head: 'DICT' 4 bytes
    $outStr .= $block_head;

    # gzip length 4 bytes
    $outStr .= chr( ($gzipLength>>24) & 255 ).chr( ($gzipLength>>16) & 255 ).chr( ($gzipLength>>8) & 255 ).chr( $gzipLength & 255 );

    # append data
    $outStr .= $gzipOutput;
}
close IN;

unlink $tmpfile;

srand(time ^ $$);
srand(int(rand(100000000)) + time);
my $Aseed = int(rand(2000000000)) ;
print "Aseed = $Aseed, nIndex = $nIndex, version = $version\n";

my $sA = $Aseed;
my $randomSequence = "";

for(my $i = 0; $i < $SequenceLength ; $i++){
    $sA  = ($a * ($sA & 65535) + $b) % ($c+$i);
    $randomSequence .= chr($sA & 255);
}

my $crypticalStr = "";
my $uncrypticalStrLen = length($outStr);
my @randomSequence = split(//,$randomSequence);
my @crc = (0,0,0,0,0,0,0,0);
my $char = 0;
my $tmp = 0;
my $i = 0;
open IN,"<",\$outStr;
while(1){
    my $buff;
    read(IN,$buff,$SequenceLength);
    my $tmpCryptialStr;
    if(length($buff) < $SequenceLength){
        my $tmpRand = substr($randomSequence,0,length($buff));
        $tmpCryptialStr = ($buff ^ $tmpRand);

    }else{
        $tmpCryptialStr = ($buff ^ $randomSequence);
    }
    $crypticalStr .= $tmpCryptialStr;

    my @arr = split(//,$tmpCryptialStr);
    foreach my $t (@arr){
        $crc[$i++%8] ^= ord($t);
    }
    last if(length($buff) < $SequenceLength);
}

$nIndex ^= (($crc[2] & 255) << 24) + (($crc[1]&255) << 16) + (($crc[7]&255) << 8) + ($crc[4]&255);

my $head = "";
$head .= chr($version & 255);
$head .= chr(($nIndex >> 24) & 255 ).chr(($nIndex >> 16) & 255 ).chr(($nIndex >> 8) & 255 ).chr(($nIndex) & 255);
$head .= chr(($Aseed >> 24) & 255 ).chr(($Aseed >> 16) & 255 ).chr(($Aseed >> 8) & 255 ).chr(($Aseed) & 255);
#保存预留字节
$i = 6;
foreach my $b (@bytes){
    $b ^= $crc[$i++%8];
    $head .= chr($b & 255);
}


foreach my $c (@crc){
    $head .= chr($c & 255);
}

my $allOut = $head.$crypticalStr;
print "writing data to $cryptfile \n...\n";
open OUT,"> $cryptfile" or die $!;
binmode(OUT);
print OUT $allOut;
close OUT;

print "\nFinished!\n";
