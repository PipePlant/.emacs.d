use strict;
use warnings;
use Data::Dumper;
use Encode;
use JSON;
use feature qw(say);

my $josn = new JSON;

my @tidyFiles = glob "./v2_data/tmp_data/*_tidy.txt";
my $logFile = "./v2_data/final_data/audio_log.txt";

open my $LOG ,">", $logFile or die $!;
foreach my $tidyFile (@tidyFiles) {
    $tidyFile =~ /(1l(\d+))/;
    my $finalFile = "./v2_data/final_data/".$1."_additional_final.txt";
    my $bookNum = $2;

    open my $TIDY ,"<", $tidyFile or die $!;
    open my $FINAL ,">", $finalFile or die $!;

    my $word = "";
    my @object = ();
    my $audioNum = 0;
    while (<$TIDY>) {
        my $line = $_;
        
        if ($line =~ /<-> (.*)/) {
            $word = $1;
        } elsif ($line =~ /(.+?)\t(.*)/) {
            my $sentence = $1;
            my $tmpAudio = $2;
            if ($tmpAudio) {
                $sentence =~ s/\[\*\]//g;
                $sentence =~ s/^ +| +$//g;
                my $auido = $bookNum."_".++$audioNum.".mp3";
                my %bookData = ();
                $bookData{"sentence"} = $sentence;
                $bookData{"audio"} = $auido;
                push @{\@object},\%bookData;
                say $LOG $tmpAudio.".mp3\t".$auido;
            }
        }
        if ($line =~ /={3,}/ or
                 eof) {
            # ```print```
            say $FINAL $word."\t".$josn->encode(\@object) if $word;
            $word = "";
            @object = ();
        } 
    }
    
    close $TIDY;
    close $FINAL;
}
close $LOG;
