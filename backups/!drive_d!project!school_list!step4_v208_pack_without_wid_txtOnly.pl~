use strict;
# require "E:/eclipse_c++/common/step0_changeName.pl";

# #studydescription_dict
# #studystructure_dict
# my $dictName = dictName();
# my $root = "E:/dict/$dictName/";

# my $txtfile = "./ps_schools.txt";
# my $txtfile = "./ps_areas.txt";
# my $txtfile = "./ps_cities.txt";

# my $txtfile = "./ps/v2_ps_schools_16Sep.txt";
my $txtfile = "./ps/v2_cities.txt";

# my $txtfile = "./jh_schools.txt";
# my $txtfile = "./jh_areas.txt";
# my $txtfile = "./jh_cities.txt";

# my $txtfile = "./sh_schools.txt";
# my $txtfile = "./sh_areas.txt";
# my $txtfile = "./sh_cities.txt";

#bin file format;
# klen(2 bytes) + dlen(4 bytes) + key + value

# my ($fileHead) = ($txtfile =~ m/^(.*)_/);
my ($fileHead) = ($txtfile =~ m/^(.*)\./);
my $cryptfile = $fileHead.'.dgz';
my $tmpfile = $fileHead."_tmp.txt";

use Data::Dumper;
use IO::Compress::Gzip qw(gzip $GzipError);
use IO::Uncompress::Gunzip qw(gunzip);

#---------- seeds ---------#
our $a = 23691;
our $b = 16430;
our $c = 24729;
my $SequenceLength = 9041;
#--------------------------#


my $version = 208;
my $buff_length = 200*1024; #200K
my $block_head = 'DICT';
my $realLength = 0;
my @bytes = (0,0,0,0,0,0);
my $hasUWID = 0;
$bytes[0] = $hasUWID;

my $buff;

my $outStr = "";
my %uwid;

my $nIndex = 0;
print "reading data from $txtfile \n...\n";

my $realbuff = "";
#my $buff;
my $len;
open IN,"< $txtfile" or die $!;
while(<IN>){
    #read(IN,$buff,2);
    #
    #last if(length($buff) < 2);
    #my @attr = split(//,$buff);
    #my $keylen = (ord($attr[0]) << 8) | ord($attr[1]);
    
    #read(IN,$buff,4);
    #@attr = split(//,$buff);
    #my $valLenStr = $buff;
    chomp;
    my ($key,$val) = split(/\t/);
    my $valLength = length($val);
    
    #my $key = "";
    #read(IN,$key,$keylen);
    
    #my $val = "";
    #read(IN,$val,$valLength);
    #print $key,"\t",$keylen,"\t",$valLength,"\n";
    #$valLength=50;
    my $valLenStr = chr( ($valLength>>24) & 255 ).chr( ($valLength>>16) & 255 ).chr( ($valLength>>8) & 255 ).chr( $valLength & 255 );
    #print $valLength."\t".$valLenStr."\n";
    $nIndex++;
    my $realLine = $key."\t".$valLenStr.$val."\n";
    #print $realLine."\n";
    if(length($realLine) + $realLength <= $buff_length){
        $realbuff .= $realLine;
        $realLength = length($realbuff);
        next;
    }
    
    #print $realbuff."\n";
    my $gzipOutput;
    gzip \$realbuff => \$gzipOutput;
    my $gzipLength = length($gzipOutput);
    
    # block head: 'DICT' 4 bytes
    $outStr .= $block_head;
    print $gzipLength,"\n";
    # gzip length 4 bytes
    $outStr .= chr( ($gzipLength>>24) & 255 ).chr( ($gzipLength>>16) & 255 ).chr( ($gzipLength>>8) & 255 ).chr( $gzipLength & 255 );
    
    # append data
    $outStr .= $gzipOutput;

    $realbuff = $realLine;
    $realLength = 0;
    
}
#print length($realbuff)," buff length\n";
if(length($realbuff) > 0){
    my $gzipOutput;
    gzip \$realbuff => \$gzipOutput;
    my $gzipLength = length($gzipOutput);
    
    # block head: 'DICT' 4 bytes
    $outStr .= $block_head;
    
    # gzip length 4 bytes
    $outStr .= chr( ($gzipLength>>24) & 255 ).chr( ($gzipLength>>16) & 255 ).chr( ($gzipLength>>8) & 255 ).chr( $gzipLength & 255 );
    
    # append data
    $outStr .= $gzipOutput;
}
close IN;

unlink $tmpfile;

srand(time ^ $$);
srand(int(rand(100000000)) + time);
my $Aseed = int(rand(2000000000)) ;
print "Aseed = $Aseed, nIndex = $nIndex, version = $version\n";

my $sA = $Aseed;
my $randomSequence = "";

for(my $i = 0; $i < $SequenceLength ; $i++){
    $sA  = ($a * ($sA & 65535) + $b) % ($c+$i);
    $randomSequence .= chr($sA & 255);
}

my $crypticalStr = "";
my $uncrypticalStrLen = length($outStr);
my @randomSequence = split(//,$randomSequence);
my @crc = (0,0,0,0,0,0,0,0);
my $char = 0;
my $tmp = 0;
my $i = 0;
open IN,"<",\$outStr;
while(1){
    my $buff;
    read(IN,$buff,$SequenceLength);
    my $tmpCryptialStr;
    if(length($buff) < $SequenceLength){
        my $tmpRand = substr($randomSequence,0,length($buff));
        $tmpCryptialStr = ($buff ^ $tmpRand);

    }else{
        $tmpCryptialStr = ($buff ^ $randomSequence);
    }
    $crypticalStr .= $tmpCryptialStr;
    
    my @arr = split(//,$tmpCryptialStr);
    foreach my $t (@arr){
        $crc[$i++%8] ^= ord($t);
    }
    last if(length($buff) < $SequenceLength);
}

$nIndex ^= (($crc[2] & 255) << 24) + (($crc[1]&255) << 16) + (($crc[7]&255) << 8) + ($crc[4]&255);

my $head = "";
$head .= chr($version & 255);
$head .= chr(($nIndex >> 24) & 255 ).chr(($nIndex >> 16) & 255 ).chr(($nIndex >> 8) & 255 ).chr(($nIndex) & 255);
$head .= chr(($Aseed >> 24) & 255 ).chr(($Aseed >> 16) & 255 ).chr(($Aseed >> 8) & 255 ).chr(($Aseed) & 255);
#保存预留字节
$i = 6;
foreach my $b (@bytes){
    $b ^= $crc[$i++%8];
    $head .= chr($b & 255);
}

foreach my $c (@crc){
    $head .= chr($c & 255);
}

my $allOut = $head.$crypticalStr;
print "writing data to $cryptfile \n...\n";
open OUT,"> $cryptfile" or die $!;
binmode(OUT);
print OUT $allOut;
close OUT;

# print "\n".$dictName." step4 has finished!";
